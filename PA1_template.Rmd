---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: yes
---
```{r echo=F,results='hide',warning=F,message=F}
library(knitr)
library("dplyr")
library("ggplot2")
#opts_chunk$set(dpi=72,dev='png')
```
## External source usage:
<strong>Multiplot function</strong>

Courtesy of Winston Chang, the author of "R Graphics Cookbook"

URL: <a href="http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/">http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/</a>

License: <small>This work is licensed under a Creative Commons Attribution-Share Alike 3.0 Unported License.
The R code is freely available for use without any restrictions. In other words: you may reuse the R code for any purpose (and under any license), but if you want to reuse the other content of this website, you must adhere to the CC license.</small>

``` {R}
# Multiple plot function
# ======================================
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```


## Loading and preprocessing the data
```{r}
# reading csv file
rawData <- read.csv("./data/activity.csv")

#processing data
## converting date column to POSIX time
rawData <- mutate(rawData, fullDate = as.POSIXct(rawData$date, format="%Y-%m-%d"))
## selecting neccessary columns, adding another column to indicate type of a day 
## (weekend or weekday type) derived from POSIX time
data <- rawData %>%
        select(steps, fullDate, interval) %>%
        mutate(dayType = as.factor(ifelse(weekdays(fullDate) == "Sunday" | weekdays(fullDate) == "Saturday", "weekend", "weekday")))
```

## What is mean total number of steps taken per day?
``` {R}
sumOfSteps <- aggregate(data$steps, by = list(date = data$fullDate), sum)
head(sumOfSteps)
qplot(sumOfSteps$x, geom="histogram", fill = I("lightgreen"), col = I("black"), xlab = "Steps", ylab = "Frequency", main = "Histogram of Total Steps Each Day", binwidth = 1000)
meanX <- mean(sumOfSteps$x, na.rm = TRUE)
print(meanX)
quantileX <- quantile(sumOfSteps$x, probs = c(.5), na.rm = TRUE)
print(quantileX)
```
The mean and the median of total number of steps taken per day are <strong>`r sprintf("%.2f", meanX)`</strong> and <strong>`r sprintf("%.2f", quantileX)`</strong>, respectively.

## What is the average daily activity pattern?
Calculate average on each 5-minute intervals
```{R}
intervalData <- aggregate(data$steps, by = list(interval = data$interval), mean, na.rm = TRUE)
head(intervalData)
p <- ggplot(data = intervalData, aes(x = interval, y = x))
p + geom_line()  + labs(x = "Interval", y = "Average Number of Steps", title = "")
maxX <- max(intervalData$x)
intervalMax <- intervalData[which(intervalData$x == max(intervalData$x)), 1]
```

Maximum number of steps is <strong>`r sprintf("%.4f", maxX)`</strong> at 5-minute interval of <strong>`r sprintf("%04d", intervalMax)`</strong>

## Imputing missing values
1. Total missing values
```{R}
nrow(data[is.na(data$steps),])
```

2. Fill up NAs with median values of each interval
```{R}

## I couldn't find a more elegant way to replace NAs with mean values for each 
## interval.  Ideally, using dplyr's mutate function would suffice.
# function(intv, intvDf) {
#        return(as.numeric(intvDf[which(intvDf$interval == intv), 2]))
#}
#newData <- mutate(data, cleanSteps = ifelse(is.na(data$steps), 
#       getMeanInterval(intv = data$interval, intvDf = intervalData), data$step))
#head(newData)

cleanSteps <- numeric()
for(i in 1:nrow(data)) {
        if(is.na(data[i, 1])){
                intv <- data[i, 3]
                cleanSteps <- c(cleanSteps, intervalData[which(intervalData$interval == intv), 2])  
        }
        else {
                cleanSteps <- c(cleanSteps, data[i, 1]) 
        }
}
newData <- cbind(data, cleanSteps = cleanSteps)         

newSumOfSteps <- aggregate(newData$cleanSteps, by = list(date = newData$fullDate), sum)
head(newSumOfSteps)
qplot(newSumOfSteps$x, geom="histogram", fill = I("lightgreen"), col = I("black"), xlab = "Steps", ylab = "Frequency", main = "Histogram of Total Steps Each Day (after imputing NAs)", binwidth = 1000)

newMeanX <- mean(newSumOfSteps$x)
print(newMeanX)
newQuantileX <- quantile(newSumOfSteps$x, probs = c(.5))
print(newQuantileX)
```
After imputing missing values, new values for the mean and the median of total number of steps taken per day are <strong>`r sprintf("%.2f", newMeanX)`</strong> and <strong>`r sprintf("%.2f", newQuantileX)`</strong>.  The mean remains the same, but the median moves closer to the mean (in this case, they are identical).

## Are there differences in activity patterns between weekdays and weekends?
A factor variable with two levels "weekday" and "weekend" has been created for the dataset <i>(Please refer to data processing code near the top of the page)</i>

``` {R}

# filter interval data of weekdays
dataWD <- filter(newData, dayType == "weekday")
dataWD <- aggregate(dataWD$cleanSteps, by = list(interval = dataWD$interval), FUN = "mean")

p2 <- ggplot(data = dataWD, aes(x = interval, y = x)) + geom_line(color = "blue")  + labs(x = "Interval", y = "Average Number of Steps", title = "Weekday") + ylim(0, 250)

# filter interval data of weekends
dataWK <- filter(newData, dayType == "weekend")
dataWK <- aggregate(dataWK$cleanSteps, by = list(interval = dataWK$interval), FUN = "mean")

p3 <- ggplot(data = dataWK, aes(x = interval, y = x)) + geom_line(color = "green")  + labs(x = "Interval", y = "Average Number of Steps", title = "Weekend") + ylim(0, 250)

multiplot(p2, p3, cols=1)

##testing
dTest <- group_by(newData, interval, dayType)
dTest <- summarise(dTest, average = mean(cleanSteps))

pTest <- ggplot(data = dTest, aes(x = interval, y = average, color = dayType))
pTest + geom_line() +  aes(group = dayType) + 
    labs(x = "Interval", y = "Average Number of Steps", title = "Test") + 
    scale_colour_discrete(name  ="Day Type",
                          breaks=c("weekday", "weekend"),
                          labels=c("Weekday", "Weekend"))

```
